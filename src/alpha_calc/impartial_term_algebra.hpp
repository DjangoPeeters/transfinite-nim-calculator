#ifndef IMPARTIAL_TERM_ALGEBRA_HPP
#define IMPARTIAL_TERM_ALGEBRA_HPP

#include "ring_buffer_queue.hpp"

#include <atomic>
#include <cstddef>
#include <cstdint>
#include <ostream>
#include <vector>
#include <boost/multiprecision/cpp_int.hpp>

using std::size_t;
using std::vector;
using boost::multiprecision::cpp_int;

struct term_array {
    uint32_t terms_size;
    uint32_t* terms;

    term_array(): terms_size(0), terms(nullptr) {}

    term_array(uint32_t size): terms_size(size), terms(new uint32_t[size]) {}

    term_array(const term_array& other): terms_size(other.terms_size), terms(nullptr) {
        if (other.terms != nullptr && other.terms_size > 0) {
            terms = new uint32_t[terms_size];
            std::memcpy(terms, other.terms, terms_size * sizeof(uint32_t));  // Faster than loop
        }
    }

    term_array(term_array&& other) noexcept : terms_size(other.terms_size), terms(other.terms) {
        other.terms = nullptr;
        other.terms_size = 0;
    }

    ~term_array() {
        if (terms != nullptr) delete[] terms;
        terms = nullptr;
        terms_size = 0;
    }

    term_array& operator=(const term_array& other) {
        if (this != &other) {
            if (terms != nullptr) delete[] terms;
            terms_size = other.terms_size;

            if (other.terms != nullptr && other.terms_size > 0) {
                terms = new uint32_t[terms_size];
                for (uint32_t i = 0; i < terms_size; i++) {
                    terms[i] = other.terms[i];
                }
            } else {
                terms = nullptr;
            }
        }
        return *this;
    }

    term_array& operator=(term_array&& other) noexcept {
        if (this != &other) {
            if (terms != nullptr) delete[] terms;
            terms_size = other.terms_size;
            terms = other.terms;
            other.terms = nullptr;
            other.terms_size = 0;
        }
        return *this;
    }

    friend bool operator!=(const term_array& me, const term_array& other) {
        if (me.terms_size != other.terms_size) return true;
        for (uint32_t i = 0; i < me.terms_size; i++) {
            if (me.terms[i] != other.terms[i]) return true;
        }
        return false;
    }
};

struct tmp_term_array { // only for transferring `term_array`'s
    uint32_t terms_size;
    uint32_t* terms;

    tmp_term_array(): terms_size(0), terms(nullptr) {}

    tmp_term_array(const term_array& other): terms_size(other.terms_size), terms(other.terms) {}

    ~tmp_term_array() {
        terms_size = 0;
        terms = nullptr;
    }

    tmp_term_array& operator=(const tmp_term_array& other) {
        if (this != &other) {
            terms_size = other.terms_size;
            terms = other.terms;
        }
        return *this;
    }
};

struct flattened_table {
    term_array* data;
    size_t* component_offsets;
    uint32_t term_count;

    flattened_table(): data(nullptr), component_offsets(nullptr), term_count(0) {}

    ~flattened_table() {
        if (data != nullptr) delete[] data;
        data = nullptr;
        if (component_offsets != nullptr) delete[] component_offsets;
        component_offsets = nullptr;
        term_count = 0;
    }
    
    term_array& get(size_t component, size_t degree, size_t term_idx) {
        size_t offset = component_offsets[component] + 
                       term_count*(degree-1) + // we ignore degree=0 because this corresponds to the trivial case with result 1 = term_array({0})
                       term_idx;
        return data[offset];
    }
};

uint32_t term_count_calc(const vector<uint16_t>& q_components);

/* q is used when something is related to non-trivial prime powers */
class impartial_term_algebra {
    private:
        ring_buffer_calculation_queue& log_queue_;
        std::atomic<bool>& calculation_done_;

        /** WARNING: q_components is supposed to represent prime powers such that
         * the corresponding algebra generated by the kappa(q)'s doesn't contain
         * kappa(Q)'s where Q is not present among q_components.
         * Example: impartial_term_algebra(..., ..., {2, 3, 5}) won't work as expected because
         * kappa(5)^5 = 4 which can't be written as a sum of products of kappa(2),kappa(3),kappa(5).
         */
        vector<uint16_t> q_components; // 16 bits will suffice here for now, also see "prime_generator.hpp"
        uint16_t* q_degrees; // ditto
        uint32_t* basis; // multiplying everything together from `q_degrees` might need more than 16 bits
        uint32_t term_count;
        uint32_t accumulator_size;
        uint64_t* accumulator; // using uint64_t to represent 64 contiguous bits
        uint32_t accumulate_size;
        term_array* kappa_table; // some entries come from `basis`
        flattened_table q_power_times_term_table; // ditto
        uint32_t* basis_search;
        term_array* square_term_table;

        term_array q_power_times_term(size_t q_index, uint16_t q_exponent, uint32_t term); // same `uint16_t` as for `q_degrees`
        term_array q_power_times_term_calc(size_t q_index, uint16_t q_exponent, uint32_t term); // ditto
        term_array term_times_term(uint32_t x, uint32_t y);

        inline void flip_accumulator_term(uint32_t x);
        inline bool accumulator_contains(uint32_t x);
        inline void clear_accumulator();
        void accumulate_term_product(uint32_t x, uint32_t y);
        term_array square_term_calc(uint32_t x);
        void square_with_table(term_array& a);
    public:
        impartial_term_algebra(ring_buffer_calculation_queue& log_queue, std::atomic<bool>& calculation_done,
            vector<uint16_t>& q_components);
        ~impartial_term_algebra();

        const vector<uint16_t>& get_q_components() const;
        uint32_t get_term_count() const;
        uint32_t* get_basis() const;

        term_array multiply(const term_array& a, const term_array& b);
        term_array square(const term_array& a);
        term_array power(const term_array& a, const cpp_int& n);
        void excess_power(const term_array&a, const cpp_int& n, term_array& res);
        uint32_t degree(const term_array& a); // not sure how much space is adequate for the result
        void q_set_degree(const term_array& a, uint32_t& res);
};

#endif